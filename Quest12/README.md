# Quest 12. 보안의 기초

## Introduction

- 이번 퀘스트에서는 가장 기초적인 웹 서비스 보안에 대해 알아보겠습니다.

## Topics

- XSS, CSRF, SQL Injection
- HTTPS, TLS

## Resources

- [The Basics of Web Application Security](https://martinfowler.com/articles/web-security-basics.html)
- [Website Security 101](https://spyrestudios.com/web-security-101/)
- [Web Security Fundamentals](https://www.shopify.com.ng/partners/blog/w ㅍeb-security-2018)
- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/)
- [Wikipedia - TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security)

## Checklist

- 입력 데이터의 Validation을 웹 프론트엔드에서 했더라도 서버에서 또 해야 할까요? 그 이유는 무엇일까요?

  > 우리가 만든 클라이언트외에서도 호출이 발생할 수 있기 때문에 프론트엔드에서 유효성 검사를 했더라도 서버에서 다시 Validation을 하는 것이 안전합니다. (쿼리, 포스트멘..)

  > - Validation이란 유효성 검사라고도 하는데 데이터의 유효성/신뢰도/위변조 여부 등 매우 넒은 범위를 포함

  - 보통 프론트엔드 유효성 검사는
    > - 1. 유저의 입력값에 대한 유효성 검증(값이 비었는가(비밀번호가 입력이 안되면 로그인 버튼이 비활성화), Data type이 일치하는가(이메일 타입인지 아닌지, 비밀번호 형식이 맞는지 아닌지, 비밀번호 확인이 일치하는지))
    > - 2. 서버로부터 받아온 값이 사용자에게 그대로 노출 가능한 상태인지의 유효성(예시가 뭐가 있지?, 서버에서 받은 데이터가 프론트에서 이해가 어려운 경우라면 별도의 처리 작업 필요)
    > - 3.  타입 에러로 프로그램을 중단시키는 에러를 막는 유효성(예시가 뭐가 있지?)
  - server: 값이 위/변조 되었는가? 유효한 값인가? 신뢰할 수 있는가?
    > - 서버에서 또 validation을 해줘야 하는 이유는 프론트의 유효성 검사는 쉽게 무력화될 수 있기 때문입니다.
    > - 개발자 도구 같은 것을 이용해서 값들을 변경하다보니, 유효성 검증은 DB에 저장되기 전에 서버에서 유효성 검사를 하는 것이 안전하다.
    > - 그렇다면 왜 클라이언트에서 해주나? 그냥 바로 서버에서 해주면 안되나? 라는 생각이 드는데
    > - 프론트에서 최대한 성공 케이스만 서버로 보내주는 것만으로도 서버가 받아야 할 콜 수를 줄일 수 있습니다.
    > - 프론트에서 보낸 유효성이 통과하여 백엔드로 넘어갔는데 유효성 검사를 통과하지 못하면 데이터를 저장하지 않고 프론트 측에 오류 메세지를 전달합니다.
  - 서버로부터 받은 HTML 내용을 그대로 검증 없이 프론트엔드에 innerHTML 등을 통해 적용하면 어떤 문제점이 있을까요?
    > - `innerHTML` 속성은 문자열 자체를 수정할 수 있기 때문에 악의를 가진 해커가 `<script>` 태그를 사용해 JavaScript 코드를 작성한 뒤 실행되도록 만들 수 있습니다.
    > - 그래서 어떤 데이터에 접근이 가능할 수 있고(다른 사용자의 정보를 훔쳐볼 수 있고) 그러면 사용자의 정보가 노출될 위험성이 있습니다.
  - XSS(Cross-site scripting)이란 어떤 공격기법일까요?
    > - 사이트간 스크립팅(또는 크로스 사이트 스크립팅)은 웹 사이트 관리자가 아닌 사람이 웹페이지에 악성 스크립트를 삽입할 수 있는 취약점입니다.
    > - 스크립트 내용에 따라 다르겠지만 쿠키나 세션 토큰 등의 탈취가 가능해서, 이를 인증이나 세션 관리에 사용하고 있는 사이트에 침입하거나 심각한 피해를 입힐 수 있습니다.
    > - 악의적으로 다른 사이트에서의 데이터를 탈취하기 위해, 정보를 훔쳐오기 위한 로직(script)을 server-side에 작성하는 행위입니다.
    > - 종류가 여러가지 입니다. Stored XSS(server side script에 행위 logic을 넣어 공격하는 방법이다.), Reflected XSS(URL parameter(querystring)에 행위 logic을 넣어 공격하는 방법이다.)
  - CSRF(Cross-site request forgery)이란 어떤 공격기법일까요?

    > - 직역하면 사이트 간 요청 위조의 줄임말입니다. 공격자가 희생자의 권한을 도용하여 특정 웹 사이트의 기능을 실행하게 할 수 있습니다.
    > - CSRF 이루어지는 과정
    > - 1. (희생자가 특정 사이트에 로그인된 상태) 희생자가 피싱 사이트에 접속
    > - 2. 피싱 사이트에서 위조된 요청을 전송
    > - 3. 희생자가 의도하지 않은 행동 실행(광고글 작성)
    > - 대응방법으로는 1.Referrer 검증 2. Security Token 사용 (A.K.A CSRF Token)이 있습니다.
    >   (\* CAPTCHA는 사용자가 직접 요청을 수행하는지 아닌지를 검사합니다.)

  - SQL Injection이란 어떤 공격기법일까요?
    > - 사용자가 특정 검색어에 관한 페이지를 요청한다고 가정했을 때, 검색어에다가 SQL 구문을 주입하는 식으로 공격이 발생할 수 있습니다.
    > - SQL 구문으로 인한 감염을 의미합니다. SQL Query를 조작하여 데이터베이스를 도용하거나 무단으로 조회하는 행위를 의미합니다.
    > - Union based injection: table에서 원하는 정보를 탈취하기 위해, 해당 정보를 조회하는 union query 문을 조작하는 행위
    > - Boolean based injection: 데이터베이스에서 특정 값이 아닌 참/거짓을 전달 받으면서 데이터를 특정해나가는 행위이다.
    > - Time based injection: Boolean based injection 과 마찬가지로 server로 부터 참/거짓에 대한 응답을 받아 데이터를 특정해나가는 행위이다. SLEEP이나 BENCHMARK 등을 이용하여 DB를 의도적으로 지연/중지할 수 있으며, 시간적 제한요소를 두기 때문에 time based injection으로 일컫습니다.

- 대부분의 최신 브라우저에서는 HTTP 대신 HTTPS가 권장됩니다. 이유가 무엇일까요?

  > - HTTPS, (HTTP over secure socket layer = HTTP SSL)란 기존 HTTP 프로토콜에 SSL/TLS 프로토콜을 적용하여 안정성이 확보된 통신 규약을 의미합니다.
  > - HTTP 프로토콜을 통한 데이터 통신 과정에 SSL/TLS 암호화 방식(양방향 암호화)를 적용하여 상대적으로 안전한 데이터 전달이 가능하도록 하였습니다.(공개키암호화하여 서버와 클라이언트간의 통신을 암호화 하여 데이터를 안전하게 전송)
  > - HTTPS를 사용한 웹 페이지를 통해 전송되는 모든 데이터는 추가적인 보안 계층이 있습니다. 이를 TLS(전송 계층 보안) 프로토콜이라고 합니다. 모든 유형의 데이터는 변경되거나 손상될 수 없는 HTTPS 사이트를 통해 전달되며 제 3자로부터 보호됩니다.
  > - 구글 검색 결과 페이지의 순위 결정 요인 중 하나입니다.

  - HTTPS와 TLS는 어떤 식으로 동작하나요? HTTPS는 어떤 역사를 가지고 있나요?

    > - 클라이언트가 서버에게 TLS 연결을 요청합니다. 이때 클라이언트는 자신의 암호화 방식 목록과 랜덤 데이터를 전송합니다.
    > - 서버는 클라이언트에게 자신의 인증서를 전송합니다. 이 인증서는 공개키를 포함하고 있으며, 서버의 신원을 인증하는 역할을 합니다.
    > - 클라이언트는 서버의 인증서를 확인하고, 서버의 공개키를 사용하여 랜덤 데이터를 암호화하여 서버에게 전송합니다. 이 과정은 서버의 신원을 확인하는 것과 동시에 클라이언트와 서버 간의 대칭키를 생성하는 것입니다.
    > - 서버는 자신의 개인키를 사용하여 대칭키를 복호화하고, 이후부터는 클라이언트와 서버는 대칭키를 사용하여 데이터를 암호화하여 통신합니다.
    > - 클라이언트와 서버는 이후 통신에서 계속해서 대칭키를 사용합니다. 이때, 대칭키는 매번 새롭게 생성되지는 않습니다. 대신, 일정 주기마다 새로운 대칭키를 생성하여 보안을 유지합니다.

    <br />
    <img width="1154" alt="스크린샷 2023-03-31 오전 1 44 03" src="https://user-images.githubusercontent.com/82071500/229019690-b80abfc6-6439-4f61-9063-da720a8a0b83.png">
    <br />
    <img width="1154" alt="스크린샷 2023-03-31 오전 1 44 03" src="https://user-images.githubusercontent.com/82071500/229019766-80aa48d8-8d91-4545-af1c-b0c6079bd8a5.png">

    > - 공개키(public key): 사람들에게 공개된 키, 정보를 암호화 할 수 있습니다.
    > - 개인키(private key): 사용자만 알고 있는 암호를 풀 수 있는 키
    > - 대칭키: 암호화, 복호화 할 때 사용하는 키가 동일한 경우 대칭키라고 합니다.
    > - HTTPS 역사
    > - 1994년에 Netscape Navigator 웹 브라우저를 위해 HTTPS를 개발하였습니다.
    > - 원래 HTTPS는 SSL 프로토콜과 함께 사용되었으나
    > - SSL이 TLS로 발전했을 때 2000년에 HTTPS는 공식적으로 RFC2818에 규정되었습니다.

  - HTTPS의 서비스 과정에서 인증서는 어떤 역할을 할까요? 인증서는 어떤 체계로 되어 있을까요?
    > - 인증서는 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지 확인해 주는 역할을 합니다.
    > - 공인된 인증 기관(CA, Certificate Authority)에서 발행되며, 해당 서버의 도메인명과 공개키(Public Key) 정보를 담고 있습니다.
    > - 클라이언트가 서버에 접속할 때, 서버는 클라이언트에게 이 인증서를 제공하고, 클라이언트는 이 인증서를 검증하여 서버의 신원을 확인합니다.
    > - 검증 과정에서는 클라이언트는 인증 기관의 공개키를 이용하여 인증서의 전자서명을 검증합니다.
    > - 인증서에는 서버의 공개키 정보뿐만 아니라, 인증 기관의 정보, 인증서의 유효 기간 등의 정보도 포함됩니다.
    > - 발급된 인증서는 해당 서버에 설치되어 사용됩니다. 또한, 인증서는 일정 기간마다 갱신되어야 하며, 기간이 만료되면 새로운 인증서를 발급받아 설치해야 합니다.

## Quest

- 메모장의 서버와 클라이언트에 대해, 로컬에서 발행한 인증서를 통해 HTTPS 서비스를 해 보세요.

## Advanced

- TLS의 인증서에 쓰이는 암호화 알고리즘은 어떤 종류가 있을까요?
  > - 대칭키 암호: RC4, 트리플 DES, AES, IDEA, DES, 아리아, ChaCha20, Camellia. 옛날 버전 SSL에서는 RC2가 쓰입니다.
  > - 해시 함수: TLS에서는 HMAC-MD5 또는 HMAC-SHA. SSL에서는 MD5와 SHA. 옛날 버전 SSL에서는 MD2와 MD4가 쓰입니다.
- HTTP/3은 기존 버전과 어떻게 다를까요? HTTP의 버전 3이 나오게 된 이유는 무엇일까요?
  > - 기존의 HTTP/1.1은 동시 전송에 대한 제한과 요청과 응답 간에 순서가 지켜지지 않는 문제가 있었습니다.
  > - HTTP/2는 이러한 문제를 개선하기 위해 개발되었지만, 여전히 연결 당 하나의 요청이 처리되는 문제가 있었습니다. 또한, HTTP/2는 기존의 TCP 연결 프로토콜 위에 구축되기 때문에 불필요한 오버헤드가 발생할 수 있습니다.
  > - 이에 대해 HTTP/3는 새로운 전송 프로토콜인 QUIC을 기반으로 하여 개발되었습니다. QUIC은 UDP를 기반으로 하는 프로토콜로, 기존의 TCP와 비교하여 빠른 속도와 안정성을 제공합니다.
