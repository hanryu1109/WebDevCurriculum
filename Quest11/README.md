# Quest 11. RDB의 기초와 ORM

## Introduction

- 이번 퀘스트에서는 데이터베이스를 다루는 방법에 대해 알아보겠습니다.

## Topics

- RDBMS
- MySQL
- ORM
- Hash
  - scrypt

## Resources

- [MySQL 101 – The basics](https://www.globo.tech/learning-center/mysql-101-basics/)
- [Sequelize](https://sequelize.org/)
- [안전한 패스워드 저장](https://d2.naver.com/helloworld/318732)

## Checklist

- RDBMS 테이블의 정규화는 무엇인가요?
  > - 중복을 최소화하면서 데이터 구조를 짜는 프로세스를 의미합니다.
  > - 왜 중복을 최소화하면서 정규화를 해야만 할까요? 이를 하지 않으면 이상 현상(Anomaly)이 발생하기 때문입니다.
  > - 이상 현상이란 정규화를 적절히 하지 않은 DB 또는 Relation(Table)에 데이터가 중복되고 이 Table에 어떠한 작업을 할 때 비합리적인 문제들이 발생하는 현상을 의미합니다.
  > - 테이블을 분해하는 정규화 단계가 정의되어 있는데, 여기서 테이블을 어떻게 분해되는지에 따라 정규화가 달라지는데, 각각의 정규화 단계는 다음과 같습니다.
  >   (사진)
- MySQL 외의 RDB에는 어떤 것들이 있나요?
  > - MySQL, PostgreSQL, MariaDB, Oracle, SQL Server, DB2, Access, SQLite
  - Relational Database 외에 다른 DB에는 어떤 것들이 있을까요?
    > - NoSQL: RDB가 아닌 것을 다 NoSQL로 보기도 합니다. (ex. Document 기반 MongoDB, Key-value 기반의 Redis, Graph 기반의 Neo4j)
    > - TSDB(시계열 데이터 베이스): influxDB (특정 분야에만 쓰임)
<br />
<img width="1059" alt="스크린샷 2023-03-31 오후 3 55 47" src="https://user-images.githubusercontent.com/82071500/229046065-d59e2575-8610-4c67-a81b-812cba231fc5.png">

- RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?
  > - 인덱싱은 검색속도를 빠르게 하기 위해 저장공간을 더 써서 인덱싱작업을 해주는 것입니다.
  > - 많이 쓰이는 인덱싱 자료구조에는 B-tree(비 트리), B+tree(비 플러스 트리)가 있습니다.
  > - 테이블의 필드에 인덱스를 생성하면 필드 값과 관련된 레코드에 대한 포인터를 보유하는 또 다른 데이터 구조가 생성됩니다. 그런 다음 이 인덱스구조가 정렬되어 이진 검색을 수행할 수 있습니다.
- ORM을 사용하는 것은 사용하지 않는 것에 비해 어떤 장단점을 가지고 있나요?
  > - ORM은 데이터베이스의 데이터와 프로그래밍 언어의 객체를 매핑하는 것입니다.
  - 장점
    > - 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.
    > - 다른 데이터베이스로 쉽게 교체 가능합니다.
    > - 여러 테이블에 쉽게 쿼리를 날릴 수 있습니다.
  - 단점
    > - SQL이 아닌 ORM을 배우고 익히게 된다는 단점이 있습니다.
    > - 일부 쿼리는 ORM 만으로는 작업이 불가능한 경우가 있습니다.
    > - 프로젝트의 복잡성이 커질수록 난이도가 올라갑니다.
    > - 복잡한 ORM 호출은 비효율적일 수가 있습니다.
  - 자바스크립트 생태계의 ORM에는 어떤 것들이 있나요?
    > - Sequelize.js
    > - Prisma
    > - TypeORM
    > - Knex
  <br />
  <img width="1792" alt="스크린샷 2023-03-28 오후 1 53 09" src="https://user-images.githubusercontent.com/82071500/229045790-f396ca23-83c0-4321-a572-19214df4e40c.png">

- 모델간의 1:1, 1:N, N:M 관계는 각각 무엇이고 어떨 때 사용하나요?
  > - 1:1 관계 방식은 엔티티가 상대 엔티티와 단 하나의 관계를 가지는 것을 말합니다. 예를 들면, "유저" 모델과 "유저 정보" 모델로 매칭을 시킬 수 있습니다.
  > - 1:N 관계 방식은 한 엔티티가 상대 엔티티를 여러 개 가질 수 있는 것을 말합니다. 예를 들면, "회사" 모델과 "회사 소속 유저" 모델로 매칭을 시킬 수 있습니다.
  > - N:M 관계 방식은 양 쪽 엔티티 모두 여러 엔티티를 가질 수 있는 것을 말합니다. 예를 들면, "영화" 모델과 "배우" 모델로 매칭을 시킬 수 있습니다.
- DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?
  > - 해시 함수를 이용하기 때문에 가능합니다.
  > - 해시 함수는 임의의 길이의 입력을 받으면 고정된 길이의 출력으로 변환해줍니다. 이 변환된 해시값이 데이터 베이스에 저장됩니다.
  > - 사용자가 다시 로그인한다고 한다면 사용자가 입력한 암호를 동일한 해시 함수를 사용하여 해시 처리합니다. 그리고 데이터베이스에 저장된 해시된 암호와 비교하여 인증을 수행합니다.
  - 해시 함수에는 어떤 것이 있나요?
    > - SHA(Secure Hash Algorithm, 현재는 sha-256이 주로 사용되어지고 있습니다), MD5, Bcrypt ...
  - 사용자의 암호를 해싱하여 저장할 때 어떤 식으로 저장하는 것이 보안에 좋을까요?
    > - 해싱함수를 사용하면 동일한 입력값에 따른 출력값이 동일합니다. 이를 알려주는 레인보우 테이블에서 해시값을 조회하여 입력값을 찾아낼 수 있습니다. 이를 방지하기 위해, 비밀번호와 salt(랜덤한 임의의 문자열) 값을 함께 넣어 해싱해야 합니다.

## Quest

- 이번에는 메모장을 파일이 아닌 DB기반으로 만들어 보고자 합니다.
  - 적절한 테이블을 설계해 보세요.
  - Sequelize를 이용하여 데이터의 모델을 만들고 어플리케이션에 적용해 보세요.
  - 사용자의 비밀번호는 해싱을 통해 저장되어야 합니다.

## Advanced

- Object–relational impedance mismatch란 어떤 개념인가요?

  > - 프로그래밍언어에서 객체와 관계형 데이터베이스의 테이블간의 차이를 말합니다.

  - 상속성: 객체에는 상속이라는 개념이 있어서 다른 객체를 상속받을수 있지만 테이블은 상속이라는 개념이 없습니다.
  - 일치: 데이터베이스에서는 기본키가 값으면 같은 레코드로 인식하지만 객체에서는 기본키가 같더라도 메모리 주소의 위치가 다르면 다른 레코드로 인식합니다.
  - 연관성: 관계를 형성할때 객체는 어느한쪽에 다른 객체를 참조함으로써 관계를 연결하는 방향성이 있지만 데이터베이스에서는 외래키를 사용하기 때문에 양쪽모두 외래키를 사용할 경우 방향성이 없을 수 있습니다.

- Foreign Key란 무엇인가요? 이것을 사용할 때의 장점과 단점은 무엇일까요?

  > - 외래키란 테이블과 테이블을 이어주는 역할을 하고있습니다.

  - 장점
    > - 테이블의 관계를 유지하면서 테이블을 분리할 수 있어서 데이터의 중복을 줄이고 그로 인해 참조 무결성(Referential Integrity)을 유지할 수 있습니다(테이블의 수정이 일어날시 외래키로 이어진 다른 테이블도 같이 수정이됨)
  - 단점
    > - 모든 데이터를 가지고 있지 않고 외래키를 이용해서 다른 테이블을 계속해서 참조해야하기때문에 성능이 감소합니다.

- 이전에 쓰이던 해시함수들에는 어떤 것이 있을까요? 패스워드 해싱의 추세의 역사는 어떻게 이어져왔나요?
  > - MD-5 → SHA-0 → SHA-1 → SHA-2 → SHA-3
  > - 예전의 해시 함수는 완벽하게 암호화되지 않았습니다. (예를 들면, 다른 인풋값에 같은 값이 나오는 해시 충돌, 값을 되돌리는 알고리즘) 기존의 해시함수를 보완하는 함수들이 등장하고 있습니다.
